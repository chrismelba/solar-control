{% extends "base.html" %}
{% from "components/device_card.html" import device_card %}

{% block title %}Solar Control Dashboard{% endblock %}

{% block heading %}Solar Control Dashboard{% endblock %}

{% block content %}
    <div class="card" id="devices">
        <h2>Controllable Devices</h2>
        <div id="deviceList" class="device-list">
            {% for device in devices %}
                {{ device_card(device, draggable=true) }}
            {% endfor %}
        </div>
    </div>

    <div class="card" id="sensor-values">
        <h2>Current Sensor Values</h2>
        <div class="sensor-grid">
            <div class="sensor-card">
                <h3>Solar Generation</h3>
                {% if sensor_values.solar_generation %}
                    <p class="value">{{ sensor_values.solar_generation.state }} {{ sensor_values.solar_generation.unit }}</p>
                    <p class="name">{{ sensor_values.solar_generation.friendly_name }}</p>
                {% else %}
                    <p class="value">Not configured</p>
                {% endif %}
            </div>
            
            <div class="sensor-card">
                <h3>Grid Power</h3>
                {% if sensor_values.grid_power %}
                    <p class="value">{{ sensor_values.grid_power.state }} {{ sensor_values.grid_power.unit }}</p>
                    <p class="name">{{ sensor_values.grid_power.friendly_name }}</p>
                {% else %}
                    <p class="value">Not configured</p>
                {% endif %}
            </div>
            
            <div class="sensor-card">
                <h3>Solar Forecast</h3>
                {% if sensor_values.solar_forecast %}
                    <p class="value">{{ sensor_values.solar_forecast.state }} {{ sensor_values.solar_forecast.unit }}</p>
                    <p class="name">{{ sensor_values.solar_forecast.friendly_name }}</p>
                {% else %}
                    <p class="value">Not configured</p>
                {% endif %}
            </div>

            <div class="sensor-card">
                <h3>Expected Energy Remaining</h3>
                <p class="value" id="expectedEnergyRemaining">Loading...</p>
                <p class="name">After battery charging</p>
            </div>

            <div class="sensor-card">
                <h3>Hours Until Sunset</h3>
                <p class="value" id="hoursUntilSunset">Loading...</p>
                <p class="name">Remaining daylight</p>
            </div>

            {% if sensor_values.tariff_rate %}
            <div class="sensor-card">
                <h3>Current Tariff</h3>
                <p class="value">{{ sensor_values.tariff_rate.state }}</p>
                <p class="name">{{ sensor_values.tariff_rate.friendly_name }}</p>
                <p class="mode">Mode: {{ sensor_values.tariff_mode|default('error') }}</p>
            </div>
            {% endif %}

            <div class="sensor-card">
                <h3>Last Sunrise</h3>
                {% if sunrise_time %}
                    <p class="value">{{ sunrise_time.split('T')[1].split(':')[0] }}:{{ sunrise_time.split('T')[1].split(':')[1] }}</p>
                    <p class="name">Today's Sunrise (Local Time)</p>
                {% else %}
                    <p class="value">Not configured</p>
                {% endif %}
            </div>

            <div class="sensor-card">
                <h3>Bring Forward Power</h3>
                {% if sensor_values.bring_forward_power %}
                    <p class="value">{{ sensor_values.bring_forward_power.state }} {{ sensor_values.bring_forward_power.unit }}</p>
                    <p class="name">{{ sensor_values.bring_forward_power.friendly_name }}</p>
                    {% if sensor_values.bring_forward_mode %}
                        <p class="mode">Mode: {{ sensor_values.bring_forward_mode.state }}</p>
                    {% endif %}
                {% else %}
                    <p class="value">Not configured</p>
                    <p class="name">Bring Forward Power</p>
                    {% if sensor_values.bring_forward_mode %}
                        <p class="mode">Mode: {{ sensor_values.bring_forward_mode.state }}</p>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </div>

    <div class="card" id="status">
        <h2>System Status</h2>
        <div class="status-content">
            <p>Loading status...</p>
            <div class="toggle-container">
                <label class="switch">
                    <input type="checkbox" id="powerOptimizationToggle">
                    <span class="slider round"></span>
                </label>
                <span class="toggle-label">Power Optimization</span>
            </div>
        </div>
    </div>

    <script>
        // Fetch status from API
        async function updateStatus() {
            try {
                const data = await apiCall('/api/status');
                
                const statusContent = document.querySelector('#status .status-content p');
                if (statusContent) {
                    statusContent.textContent = `Status: ${data.status}, Version: ${data.version}`;
                }
                    
                // Update toggle state
                const toggle = document.getElementById('powerOptimizationToggle');
                if (toggle) {
                    toggle.checked = data.power_optimization_enabled;
                }
            } catch (error) {
                console.error('Error updating status:', error);
                const statusContent = document.querySelector('#status .status-content p');
                if (statusContent) {
                    statusContent.textContent = 'Error loading status';
                }
            }
        }

        // Run control loop
        async function runControlLoop() {
            try {
                await apiCall('/api/control/run', {
                    method: 'POST'
                });
            } catch (error) {
                console.error('Error running control loop:', error);
            }
        }

        // Update status immediately and then periodically
        document.addEventListener('DOMContentLoaded', () => {
            updateStatus();
            updateForecastInfo();
            runControlLoop(); // Run control loop when page loads
            setInterval(updateStatus, 30000);  // Update every 30 seconds
            setInterval(updateForecastInfo, 60000);  // Update forecast info every minute
        });

        // Handle toggle changes
        document.getElementById('powerOptimizationToggle').addEventListener('change', async function(e) {
            try {
                await apiCall('/api/settings/power_optimization', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        enabled: e.target.checked
                    })
                });
            } catch (error) {
                console.error('Error updating power optimization:', error);
                // Revert toggle state on error
                e.target.checked = !e.target.checked;
            }
        });

        // Initialize drag and drop
        function initializeDragAndDrop() {
            const deviceList = document.getElementById('deviceList');
            const items = deviceList.querySelectorAll('.device-card.draggable');
            
            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    item.classList.add('dragging');
                });
                
                item.addEventListener('dragend', async () => {
                    item.classList.remove('dragging');
                    try {
                        await updateDeviceOrder();
                    } catch (error) {
                        console.error('Error updating device order:', error);
                        // Optionally revert the drag if it failed
                        window.location.reload();
                    }
                });
            });
            
            deviceList.addEventListener('dragover', e => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                const draggingItem = deviceList.querySelector('.dragging');
                if (!draggingItem) return;
                
                const siblings = [...deviceList.querySelectorAll('.device-card:not(.dragging)')];
                
                const nextSibling = siblings.find(sibling => {
                    const box = sibling.getBoundingClientRect();
                    const offset = e.clientY - box.top - box.height / 2;
                    return offset < 0;
                });
                
                deviceList.insertBefore(draggingItem, nextSibling);
            });

            // Add drop event handler
            deviceList.addEventListener('drop', e => {
                e.preventDefault();
                const draggingItem = deviceList.querySelector('.dragging');
                if (!draggingItem) return;
                
                const siblings = [...deviceList.querySelectorAll('.device-card:not(.dragging)')];
                
                const nextSibling = siblings.find(sibling => {
                    const box = sibling.getBoundingClientRect();
                    const offset = e.clientY - box.top - box.height / 2;
                    return offset < 0;
                });
                
                deviceList.insertBefore(draggingItem, nextSibling);
            });
        }

        async function updateDeviceOrder() {
            const items = document.querySelectorAll('.device-card');
            const orderData = Array.from(items).map((item, index) => ({
                name: item.dataset.deviceName,
                order: index
            }));
            
            try {
                const result = await apiCall('/api/devices/reorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(orderData)
                });
                
                if (result.status === 'error') {
                    throw new Error(result.message || 'Failed to update device order');
                }
            } catch (error) {
                console.error('Error updating device order:', error);
                alert('Failed to update device order. Please try again.');
                throw error; // Re-throw to be caught by the dragend handler
            }
        }

        // Initialize drag and drop when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeDragAndDrop();
            updateDeviceCards(); // Call immediately when page loads
        });

        async function updateDeviceCards() {
            try {
                const devices = await apiCall('/api/devices');
                devices.forEach(device => {
                    const card = document.querySelector(`.device-card[data-device-name="${device.name}"]`);
                    if (card) {
                        const deliveredElem = card.querySelector('.device-power-delivered');
                        if (deliveredElem) {
                            deliveredElem.textContent = `Energy Delivered: ${device.energy_delivered_today.toFixed(2)} Wh`;
                        }
                    }
                });
            } catch (error) {
                console.error('Failed to update device cards:', error);
            }
        }
        setInterval(updateDeviceCards, 60000); // Update every minute
        updateDeviceCards();

        // Update forecast information
        async function updateForecastInfo() {
            try {
                const data = await apiCall('/api/status');
                
                // Update expected energy remaining
                const expectedEnergyElem = document.getElementById('expectedEnergyRemaining');
                if (expectedEnergyElem) {
                    if (data.debug_state && data.debug_state.expected_energy_remaining !== null) {
                        expectedEnergyElem.textContent = `${data.debug_state.expected_energy_remaining.toFixed(2)} kWh`;
                    } else if (data.debug_state && data.debug_state.solar_forecast_remaining !== null) {
                        // If no battery is configured, show the raw solar forecast
                        expectedEnergyElem.textContent = `${data.debug_state.solar_forecast_remaining.toFixed(2)} kWh (raw forecast)`;
                    } else {
                        expectedEnergyElem.textContent = 'Not available';
                    }
                }
                
                // Update hours until sunset
                const hoursUntilSunsetElem = document.getElementById('hoursUntilSunset');
                if (hoursUntilSunsetElem && data.debug_state && data.debug_state.hours_until_sunset !== null) {
                    if (data.debug_state.hours_until_sunset > 0) {
                        hoursUntilSunsetElem.textContent = `${data.debug_state.hours_until_sunset.toFixed(1)}h`;
                    } else {
                        hoursUntilSunsetElem.textContent = 'Night';
                    }
                } else if (hoursUntilSunsetElem) {
                    hoursUntilSunsetElem.textContent = 'Not available';
                }
                
                // Update bring forward power
                const bringForwardCards = document.querySelectorAll('.sensor-card');
                for (const card of bringForwardCards) {
                    const title = card.querySelector('h3');
                    if (title && title.textContent === 'Bring Forward Power') {
                        if (data.debug_state && data.debug_state.bring_forward_power !== null) {
                            const valueElem = card.querySelector('.value');
                            if (valueElem) {
                                valueElem.textContent = `${data.debug_state.bring_forward_power.toFixed(0)} W`;
                            }
                        }
                        break;
                    }
                }
            } catch (error) {
                console.error('Error updating forecast info:', error);
                const expectedEnergyElem = document.getElementById('expectedEnergyRemaining');
                const hoursUntilSunsetElem = document.getElementById('hoursUntilSunset');
                if (expectedEnergyElem) expectedEnergyElem.textContent = 'Error';
                if (hoursUntilSunsetElem) hoursUntilSunsetElem.textContent = 'Error';
            }
        }
    </script>
{% endblock %} 